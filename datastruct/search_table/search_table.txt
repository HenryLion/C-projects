如何进行查找取决于查找表的结构

1、静态查找表：数据元素含有相同类型关键字，数据元素属于同一个集合。
1.1 顺序查找表：以顺序表或线性链表表示静态查找表
使用顺序查找的方法去查找平均查找长度(n+1)/2，不适用于表长比较大的情况
1.2 有序查找表：顺序存储按照关键字有序排列
1.2.1 有序表使用二分法查找
一般情况下，表长为n的二分查找的判定树的深度和含有n个结点的完全二叉树深度相同。
近似平均查找长度为log以2为底的(n+1) 再减1 (即log2(n+1)-1);
1.3 静态查找树表(各数据查找概率不等)
当每个数据查找概率不同时，使得查找次数最小的判定树称作最优二叉树
次优二叉树：使得左右数据权值和的差的绝对值最小
1.4 索引顺序表
索引顺序表 = 索引 + 顺序表(数组)。一般情况下索引是一个有序表
查找方法:
1) 由索引确定记录所在的区间
2) 在顺序表的某个区间内进行查找
所以，这也是一种缩小区间的查找方法
此法要求数据在整体上有上升或下降趋势。

2、动态查找表
2.1 二叉排序树
二叉排序树或者是一颗空树，或者具有如下特性：
1）若它左子树不空，则左子树上所有节点值均小于根节点的值。
2）若它右子树不空，则右子树上所有节点的值均大于根节点的值。
3）子树也满足上面两个条件。

2.2 二叉平衡树
由于二叉排序树会出现左右子树不平衡，导致性能差。
具有二叉查找树特性且其左右子树深度之差小于1。
当插入节点导致二叉平衡树失去平衡时，采用平衡旋转技术将新树平衡。

2.3 B 树
B树是一种平衡的多路查找树
1) 在m阶的B树上，每个非终端节点可能含有：
n个关键字Ki ( 1<= i <= n)
n个指向记录的指针Di (1 <= i <= n)
n+1个指向子树的指针Ai (0 <= i <= n)
2) 非叶子节点中的多个关键字均自小至大有序排列，即K1 < K2 < ... < Kn， 且Ai-1所指子树上的所有关键字均小于Ki;
3）树中所有叶子节点(空节点)均不带信息，且在树中的同一层次上;根节点或为叶子节点，或至少有两颗子树;其余非叶子节点至少有m/2(向上取整)棵子树，至多有m颗子树。
查找过程：
从根节点出发，沿指针搜索节点和在节点内进行顺序(或折半)查找两个过程交叉进行，若查找成功，则返回指向被查关键字所在节点的指针和关键字在节点中的位置;若查找不成功，则返回插入位置。


2.4 B+ 树
是B树的一种变形
每个叶子节点中含有n个关键字和n个指向记录的指针;并且，所有叶子节点彼此相链接构成一个有序表，其头指针指向含最小关键字的节点。
每个非叶子节点中的关键字Ki即为其相应指针Ai所指子树中关键字的最大值。
所有叶子节点都处在同一层次上，每个叶子节点中关键字的个数均介于m/2向上取整和m之间。
查找：
在B+树上，既可以进行缩小范围查找也可以进行顺序查找;
在进行缩小范围的查找时，不管成功与否，都必须查到叶子节点才能结束。

2.5 键树
关键字中的各个符号分布在从根节点到叶子的路径上，叶子节点内的符号为‘结束’的标志符。因此，键树的深度和关键字集合的大小无关。
键树被约定为是一颗有序树，同一层中兄弟节点之间所含符号自左至右有序。
存储结构可以用trie树(检索树)

3 哈希表
3.1 哈希表是什么？
对于频繁使用的查找表，希望查找次数为0,只有一个办法：预先知道所查关键字在表中的位置，也就是说，记录在表中位置和其关键字之间存在一种确定的关系。
一般情况，需建立一个函数关系，以f(key)作为关键字为key的记录在表中的位置，称此函数为哈希函数。哈希表是基于哈希函数建立的查找表。

哈系冲突：改进哈系函数只能减少冲突，而不能避免冲突。

3.2 哈希函数的构造方法
非数字关键字，需先进行数字化处理，处理好了之后，可以有下列哈希函数构造方法：
3.2.1 直接定址法
H(key) = key 或 H(key) = a * key + b
仅限于： 地址集合大小 = 关键字集合的大小
3.2.2 数字分析法
假设关键字集合中的每个关键字都是由S位数字组成，分析关键字从中提取分布均匀的若干位或他们的组合作为地址。
3.2.3 平方取中法
若3.2.2不适合，则先求关键字的平方值，以扩大关键字差别，然后取其中几位数字。
3.2.4 折叠法
若关键字的位数特别多，则可将其分段后叠加作为哈系值
3.2.5 取模
H(key) = key MOD p 
p 应为不大于m的质数或是不含20以下的质数因子。
3.2.6 随机数法
H(key) = Random (key)

哈希函数的选择：总的原则是使产生冲突的可能性降到尽可能的小。

3.3 处理冲突的方法
处理冲突的实际含义是：为产生冲突的地址寻找下一个哈希地址
3.3.1 开放定址法
为产生冲突的地址H(key)求得一个地址序列：
H0,H1,H2...,Hs
其中: H0 = H(key)
	  Hi = (H(key) + di) MOD m  
增量di有三种取法：
1）线性探测再散列
di = c * i 最简单的情况 c = 1
2) 平方探测再散列
di = 1平方，-1平方， 2平方，-2平方...
3) 随机探测再散列
di是一组伪随机数列 或 di = i * H(key)

3.3.2 链地址法
将所有哈希地址相同的记录都链接在同一链表中

3.4 哈希表的查找
假设采用开放地址处理冲突，则查找过程为:
对于给定值K，计算哈希地址
若地址上没记录，则查找不成功
若地址上关键字想等，则查找成功。
否则求下一地址，直至查找不成功或找到为止。

3.5 哈希表的删除操作
对于开放定址法来说，删除一个关键字需要做特殊处理，比如在删除位置放一个特殊的符号(如不会存在的关键字)。



