/* 树的概念 */

结点：数据元素+若干指向子树的分支
节点的度：分支的个数
树的度：树中所有节点的度的最大值
叶子节点：度为0的节点
分支节点：度大于0的节点
路径：从根到该节点所经分支和节点构成的路径
树的深度：树有多少层
森林：是m棵互不相交的树的集合

树的基本操作：查找 插入 删除


二叉树或为空树，或是由一个根节点加上两棵分别成为左子树和右子树，互不相交的二叉树组成

二叉树五种基本形态：
空树 只有根节点 右子树空  左子树空 左右子树都不空

线索二叉树：
遍历二叉树的结果是求得节点的一个线性序列，指向该线性序列中的前驱和后继的指针，称作线索

包含线索的存储结构称做线索链表

与其相应的二叉树叫线索二叉树

线索二叉树需要在各个节点添加前驱和后继的指针，这些指针指向因先序或中序或后续遍历而不同

指向前驱的指针添加在左子树为空的节点上
指向后继的指针添加在右子树为空的节点上
所以在原二叉链表的节点中欧给你增加两个标志域，做如下规定：
若该节点的左子树不空，则l_node域的指针指向其左子树，且左标志域的值为0;否则,l_node域的指针指向其前驱且左标志的值为1
若该节点的右子树不空，则r_node域的指针指向其右子树，且右标志域的值为0;否则,r_node域的指针指向其后继且右标志的值为1

所以线索链表的节点结构应当如下:
typedef struct BiTreeNode
{
	TElemType data;
	struct BiTreeNode *l_node, *r_node;
	Flag l_tag, r_tag;
} BiTreeNode, *BiTree;

森林转换成二叉树,树的各种操作可对应二叉树的操作来完成:
如果森林为空则二叉树为空
二叉树的根节点是第一棵树的根
由(t11,t12...t1m)对应得到LBT --> 即第一颗树除根外的其他子树构成二叉树的左子树
由(T2,T3...Tn)对应得到RBT  --> 其他树得到二叉树的右子树


树和森林的遍历:
先根遍历: 先访问根节点，然后依次先根遍历各颗子树
后根遍历: 先依次后根遍历各颗子树，然后访问根节点
按层次遍历：从上到下自左至右依次访问各节点

森林由三部分构成:
1、森林中第一颗树的根结点
2、森林中第一颗树的子树森林
3、森林中其他树构成的森林

森林的先序遍历:
访问森林中第一棵树的根结点
先序遍历森林中第一棵树的子树森林
先序遍历森林中其余树构成的森林

最优树的定义:
树的带权路径长度：树中所有叶子结点的带权路径长度之和
在所有含n个叶子结点并带相同权值的m叉树中，必存在一颗其带权路径长度取最小值的树，成为"最优数"

如何构造最优树(哈夫曼树):
以二叉树为例:
1)根据给定的n个权值构造n颗二叉树的集合，其中每颗二叉树中均只含一个带权值的根结点，其左/右子树为空树。
2)在树中选取其根节点的权值为最小的两颗二叉树，分别作为左右子树构造一颗新的二叉树，并置这棵新的二叉树根节点的权值为其左右子树根节点的权值之和。
3）从树集合中删除这两颗树，同时加入刚生成的新树
4）重复2）和3）两步，直至集合中只含一棵树为止。
 
前缀编码:
指的是任何一个字符的编码都不是同一字符集中另一个字符的编码的前缀。

